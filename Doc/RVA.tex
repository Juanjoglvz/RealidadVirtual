\documentclass{pre-tfg}

\usepackage{listings}
\usepackage{longtable}
\usepackage{formular}
\usepackage{mathtools}
\usepackage[pdftex]{graphicx}
\usepackage{rotating}
\usepackage[utf8]{inputenx}
\usepackage[T1]{fontenc} % Codificación de salida 
\usepackage{marvosym}
\showhelp  % comenta o borra para eliminar ayudas

\title{Programación e interacción. Lenguaje C\# en Unity 3D, control de elementos multimedia y 3D.}
\author{Javier Córdoba Romero y Juan José Corroto Martin}
\advisorFirst{Javier Alonso Albusac Jiménez}
%\advisorSecond{}
%\intensification{(INTENSIFICACIÓN)}
\docdate{2019}{Diciembre}


\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}

\usepackage{listings}
\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
}

\usepackage[
	backend=biber, 		% Backend
	sorting=none,
	defernumbers=true, 	% Para numerar al final
	style=numeric-comp, % Estilo numérico condensado
	% Descomentar las opciones siguientes para bibliografía multilingüe
%	autolang=other, 	% Requerido para opción multilingüe
%	language=auto   	% Requerido para opción multilingüe
]{biblatex}


% Línea añadida para eliminar el idioma de la fuente bibliográfica.
\AtEveryBibitem{\clearfield{note} \clearlist{language}}
% OJO: Editar si se cambia el fichero de bibliografía. 
\addbibresource{RVA.bib} 	% Fichero de bibliografía.
%\usepackage[autostyle]{csquotes}


\renewcommand*\lstlistingname{Listado}


\begin{document}

\maketitle
\tableofcontents

\newpage
\section{C\#}

\begin{lstlisting}[caption=Hello world]
public class Cosa
{
	public static void main(String[] args)
	{
		Console.WriteLine("Hello World");
	}
}
\end{lstlisting}

Citacion: \cite{Bow93}.

\subsection{Programación basada en eventos}

En algún momento he dicho que los scripts son componentes
En algún momento deberías decir que las variables públicas se pueden ver y modificar desde el editor.
En algún momento deberías decir que es posible que los componentes tengan componentes hijos.
En algún momento deberías hablar de los eventos más importantes de los comportamientos.




\section{Uso de C\# en Unity}

La primera versión del motor de juegos Unity fue lanzada en el 2005, desde entonces mucho ha cambiado en el motor, pasando por el motor de scripting, nuevas tecnologías gráficas y el modelo de licencias.

El lenguaje de scripting de Unity pasó por varias etapas, la primera de ellas fue \emph{Boo}, un lenguaje orientado a objetos usando el \emph{Common Language Runtime} (CLR) de .NET Framework, tecnología similar a la usada por \emph{Java} en su máquina virtual. La siguiente etapa pasó por usar una variante de \emph{Javascript} como lenguaje de scripting y, por último, se pasó a usar C\# como lenguaje de scripting con \emph{Visual Studio} como uno de los IDEs soportados.

C\# es un lenguaje de programación orientado a objetos y ejecutado sobre el \emph{Common Language Runtime}, usando principalmente con tipos estáticos aunque con soporte para tipos dinámicos, también se puede enfocar a una programación basada en eventos gracias a sus \emph{delegados}.

Ha conseguido obtener la condición de estándar ISO, su últimya revisión fue en 2018, con referencia: ISO 23270:2018\footnote{\url{https://www.iso.org/standard/75178.html}}

Actualmente Unity soporta más de 20 plataformas\footnote{\url{https://unity3d.com/es/unity/features/multiplatform}}, entre las que más destacan podemos encontrar: Windows, Linux, Mac, Playstation 4, Xbox One, Nintendo 3Ds, Oculus Rift, Android, iOS, WebGL, ARKit y ARCore.

C\# en Unity también permite interaccionar con los diferentes componentes del motor, como por ejemplo \emph{Mecanim}, su sistema de animación, su sistema de físicas o su sistema de componentes, lo que proporciona un control total sobre el motor y no sólo tareas de scripting in-game.

\subsection{Estructura de clases de Unity}

\subsection{Manejo de objetos de Unity desde C\#}

En esta sección se va a tratar c\'omo manipular objetos del mundo virtual desde un \textit{script} en \textit{Unity}. Como ya se ha dicho, los \textit{scripts} son componentes de los objetos. Desde cualquier \textit{script} podemos manipular cualquier otro objeto del mundo, o el mismo objeto. Esto último es especialmente f\'acil si queremos aplicar una transformación, pues tenemos acceso al componente \textit{Transform} como variable de clase. En \ref{lst:local} podemos ver como se puede acceder al componente \textit{transform} del objeto e invocar sus funciones para aplicarle una traslación. La variable \textit{transform} de ese listado no es necesario que se defina en ningún sitio del \textit{script}, sino que se tiene acceso a ella directamente. Esto es porque el componente \textit{Transform} es inherente a todos los objetos que están en la escena, puesto que todos los objetos deben de tener una transformación para saber dónde hay que dibujarlos. El resto de componentes (que deben ser añadidos manualmente), pueden ser accedidos simplemente con la función \textit{GetComponent<Tipo>()}. De esta forma podemos fácilmente aplicar transformaciones o fuerzas (en el caso de rigidBody) sobre el mismo objeto.

\begin{lstlisting}[caption={Acceso al componente transform para modificar el propio objeto}, label=lst:local]
Vector3 direction = new Vector3(mainCamera.transform.forward.x, 0, mainCamera.transform.forward.z).normalized * speed * Time.deltaTime;
Quaternion rotation = Quaternion.Euler(new Vector3(0, -transform.rotation.eulerAngles.y, 0));
transform.Translate(rotation * direction);
\end{lstlisting}

En el caso de querer modificar otro objeto, por ejemplo, en el caso de querer crear un enemigo a cierta distancia de otro, simplemente tenemos que encontrar la referencia al objeto. Esto se puede hacer muy fácilmente haciendo una variable pública y asignándola desde el editor. Sin embargo, si queremos acceder al objeto de forma dinámica o únicamente usando \textit{C\#}, se puede hacer de varias formas, todas usando funciones estáticas de la clase \textit{GameObject}:

\begin{enumerate}
\item Por nombre: usando la función \textit{GameObject.Find()}. Se puede buscar de forma directa un objeto en la escena virtual mediante su nombre, simplemente es necesario conocerlo de antemano. Este último matiz puede que sea la mayor inconveniencia, pues es probable que no sepamos de antemano el nombre del objeto, sobre todo si se ha generado dinámicamente. Esta función tratará los caracteres \"\/\" no como parte del nombre, sino como parte de una jerarquía de objetos. La documentación oficial de \textit{Unity} \footnote{\url{https://docs.unity3d.com/ScriptReference/GameObject.html}} desaconseja usar esta función cada frame.
\item Por tipo: usando la función \textit{GameObject.FindObjectOfType(Type type)}. En este caso, buscamos por tipo de objeto, teniendo un ejemplo en el listado \ref{lst:tipo}.
 Esta función retorna el \textbf{primer} objeto cargado de el tipo especificado, o \textit{null} si no existe ninguno de dicho tipo. Para conseguir un iterador de todos los objetos de ese tipo, también existe la función \textit{GameObject.FindObjectsOfType(Type type)}. La documentación oficial desaconseja utilizar estas funciones por ser más lentas que el resto.
\item Por etiqueta o \textit{tag}: usando la función \textit{GameObject.FindGameObjectWithTag(String tag)}. Esta función, al igual que la anterior, devuelve el \textbf{primer} objeto cargado con dicha tag, o \textit{null} si no encuentra ninguno. Además, lanzará una excepción si la tag no existe. Esta función es muy fácil de usar, pues \textit{Unity} tiene un sistema nativo de tags para los objetos muy simple de usar, a parte de tener tags predefinidas. El hecho de que sean simples cadenas de caracteres también lo hace más sencillo de utilizar. 
\end{enumerate}

\begin{lstlisting}[caption=Búsqueda de objetos por tipo, label=lst:tipo]
using UnityEngine;
using System.Collections;

// Search for any object of Type GUITexture,
// if found print its name, else print a message
// that says that it was not found.
public class ExampleClass : MonoBehaviour
{
    void Start()
    {
        GUITexture texture = (GUITexture)FindObjectOfType(typeof(GUITexture));
        if (texture)
            Debug.Log("GUITexture object found: " + texture.name);
        else
            Debug.Log("No GUITexture object could be found");
    }
}
\end{lstlisting}



\section{Ejemplos}

\section{Conclusion}


\section{Referencias}

\clearpage

%\phantomsection  % OJO: Ojo necesario con hyperref.
\addcontentsline{toc}{chapter}{\refname} % Añade la bibliografía al Índice de contenidos.
%---
% Opción 1: Bibliografía con todas las fuentes en un apartado.
%---
\printbibliography

\end{document}

% Local Variables:
% coding: utf-8
% mode: flyspell
% ispell-local-dictionary: "castellano8"
% mode: latex
% End:
